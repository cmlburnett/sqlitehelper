sqlitehelper is a simple python 3 library to do some basic boiler plate stuff for a project.

=== Install ===
Straight forward to install:

	sudo python setup.py install

=== Quick example ===

	import datetime
	import os.path
	from sqlitehelper import SH,DBTable,DBCol
	
	class mydb(SH):
		__schema__ = [
			DBTable('employee',
				DBCol('name', 'text'),
				DBCol('DOB', 'datetime'),
				DBCol('awesome', 'bool')
			),
			DBTable('address',
				DBCol('street', 'text'),
				DBCol('city', 'text'),
				DBCol('state', 'text'),
				DBCol('country', 'text'),
				DBCol('visits', 'integer')
			)
		]
	
		def open(self):
			"""
			Inject the above schema if file not found.
			"""
			ex = os.path.exists(self.Filename)
			super().open()
	
			if not ex:
				self.MakeDatabaseSchema()
	
	if __name__ == '__main__':
		db = mydb("foo.db")
		db.open()
	
		db.employee.insert(name='Ethyl', DOB=datetime.datetime.utcnow(), awesome=True)
		db.employee.insert(name='Bob', DOB=datetime.datetime.utcnow(), awesome=True)
		db.employee.insert(name='John', DOB=datetime.datetime.utcnow(), awesome=False)
	
		print("Current employees: %s" % (",".join( sorted([_['name'] for _ in db.employee.select("name")]) )))
	
		for e in db.employee.select('name', '`awesome`=?', [True]):
			print("Awesome employee: %s" % e['name'])
		for e in db.employee.select(['rowid','name'], '`awesome`=?', [False]):
			print("Decidedly NOT awesome employee: %s" % e['name'])
			# Get rid of that employee
			db.employee.delete({'rowid': '?'}, [e['rowid']])
	
		print("Current employees: %s" % (",".join( sorted([_['name'] for _ in db.employee.select("name")]) )))
	
		print("----------------")
	
		db.address.insert(street='1600 Pennsylvania Ave', city='Washington', state='DC', country='USA', visits=5)
		db.address.insert(street='10 Downing Street', city='London', country='England', visits=0)
	
		for a in db.address.select("*"):
			print("Address I want to visit: %s, %s, %s; been there %d times" % (a['street'], a['city'], a['country'], a['visits']))
	
		print("Go visit all of Europe")
		for a in db.address.select(["rowid","visits"], "`country`=?", ['England']):
			db.address.update({"rowid": a['rowid']}, {"visits": a['visits']+1})
	
		for a in db.address.select("*"):
			print("Address I want to visit: %s, %s, %s; been there %d times" % (a['street'], a['city'], a['country'], a['visits']))


This creates a database with two tables and some columns on them of different types.
Note that both datetime.datetime and bool objects are handled by this library with appropriate converters and adapters.

	Current employees: Bob,Ethyl,John
	Awesome employee: Ethyl
	Awesome employee: Bob
	Decidedly NOT awesome employee: John
	Current employees: Bob,Ethyl
	----------------
	Address I want to visit: 1600 Pennsylvania Ave, Washington, USA; been there 5 times
	Address I want to visit: 10 Downing Street, London, England; been there 0 times
	Go visit all of Europe
	Address I want to visit: 1600 Pennsylvania Ave, Washington, USA; been there 5 times
	Address I want to visit: 10 Downing Street, London, England; been there 1 times

=== Internals ===

Subclassing sqlitehelper.SH to include a schema is not necessary, but makes life a little easier for small projects.
Pass the filename to SH() and call open() to create/open the file.
Invoke MakeDatabaseSchema() to utilize the list of DBTable objects in __schema__ to create the schema.
This schema is also inspected and objects are added to the instance named after each table (eg, employee & address as shown above).
This reduces the need to pass the table name when calling select, insert, update, and delete.

The basic functions are:

	select(TABLE_NAME, COLUMNS, WHERE, VALUES)

		TABLE_NAME: a string containing the table name to select from
		COLUMNS: "" and "*" will retrieve all columns, otherwise a list of strings indicating column names
		WHERE: A string basically as you would type in sqlite3 that can include all sqlite operators
		VALUES: For each ? in the WHERE, provide it as an iterable here

	insert(TABLE_NAME, **columns)

		TABLE_NAME: a string containing the table name to select from
		**columns: a kwargs style named parameter passing of columns

	update(TABLE_NAME, WHERE, VALUES)

		TABLE_NAME: a string containing the table name to select from
		WHERE: a dictionary of column names and values to condition the update against
		VALUES: a dictionary of columns & values to update matching rows to

	delete(TABLE_NAME, WHERE, VALUES)

		TABLE_NAME: a string containing the table name to select from
		WHERE: a dictionary of column names and values to delete
		VALUES: For each ? in the WHERE, provide it as an iterable here

These functions are a little bit different in terms of style in how to pass arguments, but...that's what I picked. Deal with it?

